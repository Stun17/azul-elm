Схема покербота:
  Блок 1 — интерфейс пользователя
  Блок 2 — блок принятия решения.
  Блок 3 — блок сбора статистики,


=============================================================

должно быть десять функций по определению комбинации:

isHighCard, isOnePair, isTwoPair, isSet, isStraight, isFlush, isFullHouse, isQuads, isStraightFlush, isRoyalFlush.



=============================================================

K = (suit , rank)

Проверку на флеш делаем очень быструю
Флеш - это когда K1(0) == K2(0) == K3(0) == K4(0) == K5(0)

Поверки по рангам
1. Делаем пустой масив номиналов S размером в 13 элементов: от 0(двойка) до 12 (туз)
2. Инициализируем его нулями - это счётчики 
3. Для каждой карты K увеличиваем счётчик соответствующего номинала
4. Далее сортируем массив S (счётчиков номинала по возрастанию) и проверяем результат:
      1. если первый равен 4 - "каре".
      2. если первый элемент равен 3:
         2а. если второй элемент равен 2 - "фул".
         2б. если второй элемент равен 0 или 1 - "тройка"
     3. если первый элемент равен 2:
         3а. если второй элемент равен 2 - "две пары".
         3б. если второй элемент равен 0 или 1 - "пара"

как подсчитывать страйт?

проверку на стрит можно делать уже после определения всех остальных комбинаций. Стрит получится, только если нет даже пары. Ведь все карты должны быть _разные по номиналу.

Пусть будет массив S. Не сортируя его я могу задать поиск первого элемента, содержащего единицу
i=Array.IndexOf(S,1)
a затем рассматривать следующие варианты
i<0
элементов содержащих единицу нет, значит неповторяющихся номиналов нет. Это возможно только в случае 3+2 - значит Full House
i=0
Самый первый элемент массива имеет значение 1. Значит у нас в руке один Ace. Проверяем на наличие straight
Если А2345, что выражается как S(0)=S(1)=S(2)=S(3)=S(4) или 10JQKA, что выражается как S(0)=S(9)=S(10)=S(11)=S(12), то у нас straght, в противном случае сортируем массив и проверяем совпадение номиналов (на full house уже проверять не надо).
i<=8
Проверяем на наличие straight снова таким образом. Если S(i)=S(i+1)=S(i+2)=S(i+3)=S(i+4), то у нас straight. В противном случае сортируем массив и проверяем совпадение номиналов.
i>8
В этом случае straight уже быть не может, т.к. 9й элемент массива - десятка. Просто сортируем массив и проверяем совпадение номиналов.          


проблему подсчета совпадений номиналов он решил так:

For i = 0 to 4
 For j = 0 to 4
   If hand(i).face = hand(j).face AndAlso i <> j
     matches += 1
   End If
 Next j
Next i

hand(i).face - берется из структуры данных (колоды)

этот кусок кода определит только то, что на руке есть что-то "не меньше пары", а вот что именно?

счетчиков д.б. не два, а массив счетчиков (по кол-ву номиналов)
тогда достигаем нужной гибкости:

For i = 0 to 4
  For j = 0 to 4
    If hand(i).face = hand(j).face And i <> j then
      matches(face) += 1
    End If
  Next j
Next i

соответственно затем:

For i = 0 to maxfaces
  if matches(i) = 2
    pairs += 1
  elseif matches(i) = 3
    threes += 1
  elseif matches(i) = 4
    kare += 1
  endif
Next i

это будет работать при любом кол-ве карт в руке, т.е. покажет все пары, тройки и каре.

>>> слишком много переменных вводится, тогда уж лучше массив...

=============================================================
