<html>
<head>
</head>
<body>
<p>The first step is to setup the skeleton of the code such that it works. In order to do so, I created three files. One file containing the code for the bot (databloggerbot.py), another file containing the code for a bot which always calls and another file for simulating one game of poker (simulate.py) in which many runs are simulated. The files initially have the following contents:</p><div class="code-embed-wrapper">
<pre class="language-python code-embed-pre"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">from pypokerengine.engine.hand_evaluator import HandEvaluator
from pypokerengine.players import BasePokerPlayer
from pypokerengine.utils.card_utils import _pick_unused_card, _fill_community_card, gen_cards


# Estimate the ratio of winning games given the current state of the game
def estimate_win_rate(nb_simulation, nb_player, hole_card, community_card=None):
    if not community_card: community_card = []

    # Make lists of Card objects out of the list of cards
    community_card = gen_cards(community_card)
    hole_card = gen_cards(hole_card)

    # Estimate the win count by doing a Monte Carlo simulation
    win_count = sum([montecarlo_simulation(nb_player, hole_card, community_card) for _ in range(nb_simulation)])
    return 1.0 * win_count / nb_simulation


def montecarlo_simulation(nb_player, hole_card, community_card):
    # Do a Monte Carlo simulation given the current state of the game by evaluating the hands
    community_card = _fill_community_card(community_card, used_card=hole_card + community_card)
    unused_cards = _pick_unused_card((nb_player - 1) * 2, hole_card + community_card)
    opponents_hole = [unused_cards[2 * i:2 * i + 2] for i in range(nb_player - 1)]
    opponents_score = [HandEvaluator.eval_hand(hole, community_card) for hole in opponents_hole]
    my_score = HandEvaluator.eval_hand(hole_card, community_card)
    return 1 if my_score &gt;= max(opponents_score) else 0


class DataBloggerBot(BasePokerPlayer):
    def __init__(self):
        super().__init__()
        self.wins = 0
        self.losses = 0

    def declare_action(self, valid_actions, hole_card, round_state):
        # Estimate the win rate
        win_rate = estimate_win_rate(100, self.num_players, hole_card, round_state[&#039;community_card&#039;])

        # Check whether it is possible to call
        can_call = len([item for item in valid_actions if item[&#039;action&#039;] == &#039;call&#039;]) &gt; 0
        if can_call:
            # If so, compute the amount that needs to be called
            call_amount = [item for item in valid_actions if item[&#039;action&#039;] == &#039;call&#039;][0][&#039;amount&#039;]
        else:
            call_amount = 0

        amount = None

        # If the win rate is large enough, then raise
        if win_rate &gt; 0.5:
            raise_amount_options = [item for item in valid_actions if item[&#039;action&#039;] == &#039;raise&#039;][0][&#039;amount&#039;]
            if win_rate &gt; 0.85:
                # If it is extremely likely to win, then raise as much as possible
                action = &#039;raise&#039;
                amount = raise_amount_options[&#039;max&#039;]
            elif win_rate &gt; 0.75:
                # If it is likely to win, then raise by the minimum amount possible
                action = &#039;raise&#039;
                amount = raise_amount_options[&#039;min&#039;]
            else:
                # If there is a chance to win, then call
                action = &#039;call&#039;
        else:
            action = &#039;call&#039; if can_call and call_amount == 0 else &#039;fold&#039;

        # Set the amount
        if amount is None:
            items = [item for item in valid_actions if item[&#039;action&#039;] == action]
            amount = items[0][&#039;amount&#039;]

        return action, amount

    def receive_game_start_message(self, game_info):
        self.num_players = game_info[&#039;player_num&#039;]

    def receive_round_start_message(self, round_count, hole_card, seats):
        pass

    def receive_street_start_message(self, street, round_state):
        pass

    def receive_game_update_message(self, action, round_state):
        pass

    def receive_round_result_message(self, winners, hand_info, round_state):
        is_winner = self.uuid in [item[&#039;uuid&#039;] for item in winners]
        self.wins += int(is_winner)
        self.losses += int(not is_winner)


def setup_ai():
    return DataBloggerBot()</code></pre><div class="code-embed-infos"> <span class="code-embed-name">databloggerbot.py</span></div></div><div class="code-embed-wrapper">
<pre class="language-python code-embed-pre"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">from pypokerengine.players import BasePokerPlayer
import numpy as np
from sklearn.neural_network import MLPRegressor


class CallBot(BasePokerPlayer):
    def declare_action(self, valid_actions, hole_card, round_state):
        actions = [item for item in valid_actions if item[&#039;action&#039;] in [&#039;call&#039;]]
        return list(np.random.choice(actions).values())

    def receive_game_start_message(self, game_info):
        pass

    def receive_round_start_message(self, round_count, hole_card, seats):
        pass

    def receive_street_start_message(self, street, round_state):
        pass

    def receive_game_update_message(self, action, round_state):
        pass

    def receive_round_result_message(self, winners, hand_info, round_state):
        pass


def setup_ai():
    return CallBot()</code></pre><div class="code-embed-infos"> <span class="code-embed-name">callbot.py</span></div></div><div class="code-embed-wrapper">
<pre class="language-python code-embed-pre"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">from pypokerengine.api.game import start_poker, setup_config

from callbot import CallBot
from databloggerbot import DataBloggerBot
import numpy as np

if __name__ == &#039;__main__&#039;:
    blogger_bot = DataBloggerBot()

    # The stack log contains the stacks of the Data Blogger bot after each game (the initial stack is 100)
    stack_log = []
    for round in range(1000):
        p1, p2 = blogger_bot, CallBot()

        config = setup_config(max_round=5, initial_stack=100, small_blind_amount=5)
        config.register_player(name=&quot;p1&quot;, algorithm=p1)
        config.register_player(name=&quot;p2&quot;, algorithm=p2)
        game_result = start_poker(config, verbose=0)

        stack_log.append([player[&#039;stack&#039;] for player in game_result[&#039;players&#039;] if player[&#039;uuid&#039;] == blogger_bot.uuid])
        print(&#039;Avg. stack:&#039;, &#039;%d&#039; % (int(np.mean(stack_log))))</code></pre><div class="code-embed-infos"> <span class="code-embed-name">simulate.py</span></div></div>
<p>The bot uses Monte Carlo simulations running from a given state. Suppose you start with 2 high cards (two Kings for example), then the chances are high that you will win. The Monte Carlo simulation then simulates a given number of games from that point and evaluates which percentage of games you will win given these cards. If another King shows during the flop, then your chance of winning will increase. The Monte Carlo simulation starting at that point, will yield a higher winning probability since you will win more games on average.</p>
<p>If we run the simulations, you can see that the bot based on Monte Carlo simulations outperforms the always calling bot. If you start with a stack of $100,-, you will on average end with a stack of $120,- (when playing against the always-calling bot).</p>
<p>It is also possible to play against our bot in the GUI. You first need to setup the configuration (as described in the Git repository) and you can then run the following command to start up the GUI:</p><div class="code-embed-wrapper">
<pre class="language-bash code-embed-pre"  data-start="1" data-line-offset="0"><code class="language-bash code-embed-code">pypokergui serve poker_conf.yaml --port 8000 --speed moderate</code></pre><div class="code-embed-infos"></div></div>
<p>Good luck beating the bot!</p>
</body></html>
